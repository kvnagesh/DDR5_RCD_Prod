
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.33 (git sha1 2584903a060)


-- Executing script file `netlists/reg_err_detect_synth.ys' --

1. Executing Verilog-2005 frontend: rtl/reg_err_detect.sv
Parsing SystemVerilog input from `rtl/reg_err_detect.sv' to AST representation.
Generating RTLIL representation for module `\reg_err_detect'.
Warning: Replacing memory \log_type_mem with list of registers. See rtl/reg_err_detect.sv:148
Warning: Replacing memory \log_data_mem with list of registers. See rtl/reg_err_detect.sv:147
Warning: Replacing memory \log_addr_mem with list of registers. See rtl/reg_err_detect.sv:146
Successfully finished Verilog frontend.

2. Executing HIERARCHY pass (managing design hierarchy).

2.1. Analyzing design hierarchy..
Top module:  \reg_err_detect

2.2. Analyzing design hierarchy..
Top module:  \reg_err_detect
Removed 0 unused modules.

3. Executing PROC pass (convert processes to netlists).

3.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 12 switch rules as full_case in process $proc$rtl/reg_err_detect.sv:79$16 in module reg_err_detect.
Removed a total of 0 dead cases.

3.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 5 redundant assignments.
Promoted 6 assignments to connections.

3.4. Executing PROC_INIT pass (extract init attributes).

3.5. Executing PROC_ARST pass (detect async resets in processes).
Found async reset \rst_n in `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.

3.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~11 debug messages>

3.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
     1/71: $2$mem2reg_wr$\log_type_mem$rtl/reg_err_detect.sv:148$3_ADDR[3:0]$44
     2/71: $2$mem2reg_wr$\log_type_mem$rtl/reg_err_detect.sv:148$3_DATA[2:0]$45
     3/71: $2$mem2reg_wr$\log_data_mem$rtl/reg_err_detect.sv:147$2_ADDR[3:0]$42
     4/71: $2$mem2reg_wr$\log_data_mem$rtl/reg_err_detect.sv:147$2_DATA[31:0]$43
     5/71: $2$mem2reg_wr$\log_addr_mem$rtl/reg_err_detect.sv:146$1_ADDR[3:0]$40
     6/71: $2$mem2reg_wr$\log_addr_mem$rtl/reg_err_detect.sv:146$1_DATA[7:0]$41
     7/71: $0\alert_line[0:0]
     8/71: $0\err_code[7:0]
     9/71: $1$mem2reg_wr$\log_type_mem$rtl/reg_err_detect.sv:148$3_DATA[2:0]$29
    10/71: $1$mem2reg_wr$\log_type_mem$rtl/reg_err_detect.sv:148$3_ADDR[3:0]$28
    11/71: $1$mem2reg_wr$\log_data_mem$rtl/reg_err_detect.sv:147$2_DATA[31:0]$27
    12/71: $1$mem2reg_wr$\log_data_mem$rtl/reg_err_detect.sv:147$2_ADDR[3:0]$26
    13/71: $1$mem2reg_wr$\log_addr_mem$rtl/reg_err_detect.sv:146$1_DATA[7:0]$25
    14/71: $1$mem2reg_wr$\log_addr_mem$rtl/reg_err_detect.sv:146$1_ADDR[3:0]$24
    15/71: $0\log_valid[0:0]
    16/71: $0\warn_flag[0:0]
    17/71: $0\err_flag[0:0]
    18/71: $0\log_type_mem[15][2:0]
    19/71: $0\log_type_mem[14][2:0]
    20/71: $0\log_type_mem[13][2:0]
    21/71: $0\log_type_mem[12][2:0]
    22/71: $0\log_type_mem[11][2:0]
    23/71: $0\log_type_mem[10][2:0]
    24/71: $0\log_type_mem[9][2:0]
    25/71: $0\log_type_mem[8][2:0]
    26/71: $0\log_type_mem[7][2:0]
    27/71: $0\log_type_mem[6][2:0]
    28/71: $0\log_type_mem[5][2:0]
    29/71: $0\log_type_mem[4][2:0]
    30/71: $0\log_type_mem[3][2:0]
    31/71: $0\log_type_mem[2][2:0]
    32/71: $0\log_type_mem[1][2:0]
    33/71: $0\log_type_mem[0][2:0]
    34/71: $0\log_data_mem[15][31:0]
    35/71: $0\log_data_mem[14][31:0]
    36/71: $0\log_data_mem[13][31:0]
    37/71: $0\log_data_mem[12][31:0]
    38/71: $0\log_data_mem[11][31:0]
    39/71: $0\log_data_mem[10][31:0]
    40/71: $0\log_data_mem[9][31:0]
    41/71: $0\log_data_mem[8][31:0]
    42/71: $0\log_data_mem[7][31:0]
    43/71: $0\log_data_mem[6][31:0]
    44/71: $0\log_data_mem[5][31:0]
    45/71: $0\log_data_mem[4][31:0]
    46/71: $0\log_data_mem[3][31:0]
    47/71: $0\log_data_mem[2][31:0]
    48/71: $0\log_data_mem[1][31:0]
    49/71: $0\log_data_mem[0][31:0]
    50/71: $0\log_addr_mem[15][7:0]
    51/71: $0\log_addr_mem[14][7:0]
    52/71: $0\log_addr_mem[13][7:0]
    53/71: $0\log_addr_mem[12][7:0]
    54/71: $0\log_addr_mem[11][7:0]
    55/71: $0\log_addr_mem[10][7:0]
    56/71: $0\log_addr_mem[9][7:0]
    57/71: $0\log_addr_mem[8][7:0]
    58/71: $0\log_addr_mem[7][7:0]
    59/71: $0\log_addr_mem[6][7:0]
    60/71: $0\log_addr_mem[5][7:0]
    61/71: $0\log_addr_mem[4][7:0]
    62/71: $0\log_addr_mem[3][7:0]
    63/71: $0\log_addr_mem[2][7:0]
    64/71: $0\log_addr_mem[1][7:0]
    65/71: $0\log_addr_mem[0][7:0]
    66/71: $0\log_ptr[3:0]
    67/71: $0\log_access_type[2:0]
    68/71: $0\log_data[31:0]
    69/71: $0\log_addr[7:0]
    70/71: $0\warn_counter[15:0]
    71/71: $0\err_counter[15:0]

3.8. Executing PROC_DLATCH pass (convert process syncs to latches).

3.9. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\reg_err_detect.\err_flag' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$826' with positive edge clock and negative level reset.
Creating register for signal `\reg_err_detect.\warn_flag' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$827' with positive edge clock and negative level reset.
Creating register for signal `\reg_err_detect.\err_code' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$828' with positive edge clock and negative level reset.
Creating register for signal `\reg_err_detect.\err_counter' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$829' with positive edge clock and negative level reset.
Creating register for signal `\reg_err_detect.\warn_counter' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$830' with positive edge clock and negative level reset.
Creating register for signal `\reg_err_detect.\alert_line' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$831' with positive edge clock and negative level reset.
Creating register for signal `\reg_err_detect.\log_addr' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$834' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$837' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_access_type' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$840' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_valid' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$841' with positive edge clock and negative level reset.
Creating register for signal `\reg_err_detect.\log_ptr' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$842' with positive edge clock and negative level reset.
Creating register for signal `\reg_err_detect.\log_addr_mem[0]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$845' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[1]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$848' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[2]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$851' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[3]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$854' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[4]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$857' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[5]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$860' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[6]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$863' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[7]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$866' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[8]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$869' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[9]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$872' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[10]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$875' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[11]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$878' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[12]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$881' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[13]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$884' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[14]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$887' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_addr_mem[15]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$890' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[0]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$893' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[1]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$896' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[2]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$899' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[3]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$902' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[4]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$905' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[5]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$908' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[6]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$911' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[7]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$914' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[8]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$917' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[9]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$920' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[10]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$923' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[11]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$926' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[12]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$929' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[13]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$932' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[14]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$935' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_data_mem[15]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$938' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[0]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$941' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[1]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$944' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[2]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$947' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[3]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$950' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[4]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$953' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[5]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$956' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[6]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$959' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[7]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$962' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[8]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$965' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[9]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$968' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[10]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$971' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[11]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$974' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[12]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$977' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[13]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$980' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[14]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$983' with positive edge clock.
Creating register for signal `\reg_err_detect.\log_type_mem[15]' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $dff cell `$procdff$986' with positive edge clock.
Creating register for signal `\reg_err_detect.$mem2reg_wr$\log_addr_mem$rtl/reg_err_detect.sv:146$1_ADDR' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$987' with positive edge clock and negative level reset.
Creating register for signal `\reg_err_detect.$mem2reg_wr$\log_addr_mem$rtl/reg_err_detect.sv:146$1_DATA' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$988' with positive edge clock and negative level reset.
Creating register for signal `\reg_err_detect.$mem2reg_wr$\log_data_mem$rtl/reg_err_detect.sv:147$2_ADDR' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$989' with positive edge clock and negative level reset.
Creating register for signal `\reg_err_detect.$mem2reg_wr$\log_data_mem$rtl/reg_err_detect.sv:147$2_DATA' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$990' with positive edge clock and negative level reset.
Creating register for signal `\reg_err_detect.$mem2reg_wr$\log_type_mem$rtl/reg_err_detect.sv:148$3_ADDR' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$991' with positive edge clock and negative level reset.
Creating register for signal `\reg_err_detect.$mem2reg_wr$\log_type_mem$rtl/reg_err_detect.sv:148$3_DATA' using process `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
  created $adff cell `$procdff$992' with positive edge clock and negative level reset.

3.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

3.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 11 empty switches in `\reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
Removing empty process `reg_err_detect.$proc$rtl/reg_err_detect.sv:79$16'.
Cleaned up 11 empty switches.

3.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.
<suppressed ~31 debug messages>

4. Executing OPT pass (performing simple optimizations).

4.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.

4.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
<suppressed ~120 debug messages>
Removed a total of 40 cells.

4.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \reg_err_detect..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$67.
    dead port 2/2 on $mux $procmux$67.
    dead port 1/2 on $mux $procmux$64.
    dead port 2/2 on $mux $procmux$64.
    dead port 1/2 on $mux $procmux$61.
    dead port 2/2 on $mux $procmux$61.
    dead port 1/2 on $mux $procmux$58.
    dead port 2/2 on $mux $procmux$58.
    dead port 1/2 on $mux $procmux$55.
    dead port 2/2 on $mux $procmux$55.
    dead port 1/2 on $mux $procmux$52.
    dead port 2/2 on $mux $procmux$52.
Removed 12 multiplexer ports.
<suppressed ~60 debug messages>

4.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \reg_err_detect.
Performed a total of 0 changes.

4.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
<suppressed ~15 debug messages>
Removed a total of 5 cells.

4.6. Executing OPT_DFF pass (perform DFF optimizations).
Adding EN signal on $procdff$938 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[15]).
Adding EN signal on $procdff$941 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[0]).
Adding EN signal on $procdff$944 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[1]).
Adding EN signal on $procdff$929 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[12]).
Adding EN signal on $procdff$932 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[13]).
Adding EN signal on $procdff$935 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[14]).
Adding EN signal on $procdff$926 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[11]).
Adding EN signal on $procdff$923 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[10]).
Adding EN signal on $procdff$920 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[9]).
Adding EN signal on $procdff$947 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[2]).
Adding EN signal on $procdff$950 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[3]).
Adding EN signal on $procdff$953 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[4]).
Adding EN signal on $procdff$956 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[5]).
Adding EN signal on $procdff$959 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[6]).
Adding EN signal on $procdff$962 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[7]).
Adding EN signal on $procdff$965 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[8]).
Adding EN signal on $procdff$968 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[9]).
Adding EN signal on $procdff$971 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[10]).
Adding EN signal on $procdff$974 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[11]).
Adding EN signal on $procdff$977 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[12]).
Adding EN signal on $procdff$980 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[13]).
Adding EN signal on $procdff$983 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[14]).
Adding EN signal on $procdff$986 ($dff) from module reg_err_detect (D = \log_access_type, Q = \log_type_mem[15]).
Adding EN signal on $procdff$829 ($adff) from module reg_err_detect (D = $procmux$824_Y, Q = \err_counter).
Adding EN signal on $procdff$830 ($adff) from module reg_err_detect (D = $procmux$794_Y, Q = \warn_counter).
Adding EN signal on $procdff$834 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr).
Adding EN signal on $procdff$837 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:151$47_Y, Q = \log_data).
Adding EN signal on $procdff$840 ($dff) from module reg_err_detect (D = $procmux$776_Y, Q = \log_access_type).
Adding SRST signal on $auto$ff.cc:266:slice$1084 ($dffe) from module reg_err_detect (D = $procmux$773_Y [1:0], Q = \log_access_type [1:0], rval = 2'01).
Adding SRST signal on $auto$ff.cc:266:slice$1084 ($dffe) from module reg_err_detect (D = $procmux$767_Y [2], Q = \log_access_type [2], rval = 1'0).
Adding EN signal on $procdff$842 ($adff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:153$50_Y [3:0], Q = \log_ptr).
Adding EN signal on $procdff$845 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[0]).
Adding EN signal on $procdff$848 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[1]).
Adding EN signal on $procdff$851 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[2]).
Adding EN signal on $procdff$854 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[3]).
Adding EN signal on $procdff$857 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[4]).
Adding EN signal on $procdff$860 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[5]).
Adding EN signal on $procdff$863 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[6]).
Adding EN signal on $procdff$866 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[7]).
Adding EN signal on $procdff$869 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[8]).
Adding EN signal on $procdff$872 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[9]).
Adding EN signal on $procdff$875 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[10]).
Adding EN signal on $procdff$878 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[11]).
Adding EN signal on $procdff$881 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[12]).
Adding EN signal on $procdff$884 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[13]).
Adding EN signal on $procdff$887 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[14]).
Adding EN signal on $procdff$890 ($dff) from module reg_err_detect (D = \reg_addr, Q = \log_addr_mem[15]).
Adding EN signal on $procdff$893 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[0]).
Adding EN signal on $procdff$896 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[1]).
Adding EN signal on $procdff$899 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[2]).
Adding EN signal on $procdff$902 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[3]).
Adding EN signal on $procdff$905 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[4]).
Adding EN signal on $procdff$908 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[5]).
Adding EN signal on $procdff$911 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[6]).
Adding EN signal on $procdff$914 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[7]).
Adding EN signal on $procdff$917 ($dff) from module reg_err_detect (D = $ternary$rtl/reg_err_detect.sv:147$46_Y, Q = \log_data_mem[8]).
Setting constant 1-bit at position 0 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 1 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 2 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 3 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 4 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 5 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 6 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 7 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 8 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 9 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 10 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 11 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 12 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 13 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 14 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 15 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 16 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 17 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 18 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 19 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 20 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 21 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 22 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 23 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 24 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 25 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 26 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 27 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 28 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 29 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 30 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 31 on $procdff$990 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 0 on $procdff$992 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 1 on $procdff$992 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 2 on $procdff$992 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 0 on $procdff$988 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 1 on $procdff$988 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 2 on $procdff$988 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 3 on $procdff$988 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 4 on $procdff$988 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 5 on $procdff$988 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 6 on $procdff$988 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 7 on $procdff$988 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 0 on $procdff$991 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 1 on $procdff$991 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 2 on $procdff$991 ($adff) from module reg_err_detect.
Setting constant 1-bit at position 3 on $procdff$991 ($adff) from module reg_err_detect.

4.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \reg_err_detect..
Removed 276 unused cells and 520 unused wires.
<suppressed ~330 debug messages>

4.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.

4.9. Rerunning OPT passes. (Maybe there is more to do..)

4.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \reg_err_detect..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~11 debug messages>

4.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \reg_err_detect.
Performed a total of 0 changes.

4.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
<suppressed ~3 debug messages>
Removed a total of 1 cells.

4.13. Executing OPT_DFF pass (perform DFF optimizations).

4.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \reg_err_detect..
Removed 0 unused cells and 1 unused wires.
<suppressed ~1 debug messages>

4.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.

4.16. Rerunning OPT passes. (Maybe there is more to do..)

4.17. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \reg_err_detect..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~11 debug messages>

4.18. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \reg_err_detect.
Performed a total of 0 changes.

4.19. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
Removed a total of 0 cells.

4.20. Executing OPT_DFF pass (perform DFF optimizations).

4.21. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \reg_err_detect..

4.22. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.

4.23. Finished OPT passes. (There is nothing left to do.)

5. Executing FSM pass (extract and optimize FSM).

5.1. Executing FSM_DETECT pass (finding FSMs in design).
Not marking reg_err_detect.err_code as FSM state register:
    Register is connected to module port.
    Users of register don't seem to benefit from recoding.

5.2. Executing FSM_EXTRACT pass (extracting FSM from design).

5.3. Executing FSM_OPT pass (simple optimizations of FSMs).

5.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \reg_err_detect..

5.5. Executing FSM_OPT pass (simple optimizations of FSMs).

5.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

5.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

5.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

6. Executing OPT pass (performing simple optimizations).

6.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.

6.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
Removed a total of 0 cells.

6.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \reg_err_detect..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~11 debug messages>

6.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \reg_err_detect.
Performed a total of 0 changes.

6.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
Removed a total of 0 cells.

6.6. Executing OPT_DFF pass (perform DFF optimizations).

6.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \reg_err_detect..

6.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.

6.9. Finished OPT passes. (There is nothing left to do.)

7. Executing MEMORY pass.

7.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

7.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

7.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).

7.4. Executing MEMORY_BMUX2ROM pass (converting muxes to ROMs).

7.5. Executing MEMORY_DFF pass (merging $dff cells to $memrd).

7.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \reg_err_detect..

7.7. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

7.8. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

7.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \reg_err_detect..

7.10. Executing MEMORY_COLLECT pass (generating $mem cells).

7.11. Executing MEMORY_MAP pass (converting memories to logic and flip-flops).

8. Executing OPT pass (performing simple optimizations).

8.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.

8.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
Removed a total of 0 cells.

8.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \reg_err_detect..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~11 debug messages>

8.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \reg_err_detect.
Performed a total of 0 changes.

8.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
Removed a total of 0 cells.

8.6. Executing OPT_DFF pass (perform DFF optimizations).

8.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \reg_err_detect..

8.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.

8.9. Finished OPT passes. (There is nothing left to do.)

9. Executing TECHMAP pass (map to technology primitives).

9.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/techmap.v
Parsing Verilog input from `/usr/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

9.2. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $and.
Using extmapper simplemap for cells of type $eqx.
Using extmapper simplemap for cells of type $or.
Using extmapper simplemap for cells of type $reduce_xor.
Using extmapper simplemap for cells of type $xor.
Running "alumacc" on wrapper $extern:wrap:$add:A_SIGNED=0:A_WIDTH=16:B_SIGNED=0:B_WIDTH=32:Y_WIDTH=32:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$add:A_SIGNED=0:A_WIDTH=16:B_SIGNED=0:B_WIDTH=32:Y_WIDTH=32:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$add:A_SIGNED=0:A_WIDTH=16:B_SIGNED=0:B_WIDTH=32:Y_WIDTH=32:394426c56d1a028ba8fdd5469b163e04011def47.
Using extmapper simplemap for cells of type $logic_or.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $ne.
Using extmapper simplemap for cells of type $adff.
Using extmapper simplemap for cells of type $adffe.
Using extmapper simplemap for cells of type $dffe.
Using extmapper simplemap for cells of type $sdffce.
Using extmapper simplemap for cells of type $reduce_and.
Using template $paramod$2bd81f420048247ff6903399c560fe0f8bd48ccc\_90_alu for cells of type $alu.
Using template $paramod\_90_lcu\WIDTH=32'00000000000000000000000000100000 for cells of type $lcu.
Using extmapper simplemap for cells of type $pos.
No more expansions possible.
<suppressed ~620 debug messages>

10. Executing OPT pass (performing simple optimizations).

10.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.
<suppressed ~770 debug messages>

10.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
<suppressed ~69 debug messages>
Removed a total of 23 cells.

10.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \reg_err_detect..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

10.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \reg_err_detect.
Performed a total of 0 changes.

10.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
Removed a total of 0 cells.

10.6. Executing OPT_DFF pass (perform DFF optimizations).
Setting constant 0-bit at position 0 on $auto$ff.cc:266:slice$1763 ($_DFF_PN0_) from module reg_err_detect.

10.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \reg_err_detect..
Removed 89 unused cells and 338 unused wires.
<suppressed ~91 debug messages>

10.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.

10.9. Rerunning OPT passes. (Maybe there is more to do..)

10.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \reg_err_detect..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

10.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \reg_err_detect.
Performed a total of 0 changes.

10.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
Removed a total of 0 cells.

10.13. Executing OPT_DFF pass (perform DFF optimizations).

10.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \reg_err_detect..

10.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.

10.16. Finished OPT passes. (There is nothing left to do.)

11. Executing ABC pass (technology mapping using ABC).

11.1. Extracting gate netlist of module `\reg_err_detect' to `<abc-temp-dir>/input.blif'..
Extracted 244 gates and 354 wires to a netlist network with 107 inputs and 78 outputs.

11.1.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + &get -n 
ABC: + &fraig -x 
ABC: + &put 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

11.1.2. Re-integrating ABC results.
ABC RESULTS:               XOR cells:       26
ABC RESULTS:               AND cells:      136
ABC RESULTS:               NOT cells:       17
ABC RESULTS:                OR cells:       49
ABC RESULTS:        internal signals:      169
ABC RESULTS:           input signals:      107
ABC RESULTS:          output signals:       78
Removing temp directory.

12. Executing OPT pass (performing simple optimizations).

12.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.
<suppressed ~16 debug messages>

12.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
<suppressed ~9 debug messages>
Removed a total of 3 cells.

12.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \reg_err_detect..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

12.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \reg_err_detect.
Performed a total of 0 changes.

12.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
Removed a total of 0 cells.

12.6. Executing OPT_DFF pass (perform DFF optimizations).

12.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \reg_err_detect..
Removed 0 unused cells and 189 unused wires.
<suppressed ~2 debug messages>

12.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.

12.9. Rerunning OPT passes. (Maybe there is more to do..)

12.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \reg_err_detect..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

12.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \reg_err_detect.
Performed a total of 0 changes.

12.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\reg_err_detect'.
Removed a total of 0 cells.

12.13. Executing OPT_DFF pass (perform DFF optimizations).

12.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \reg_err_detect..

12.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module reg_err_detect.

12.16. Finished OPT passes. (There is nothing left to do.)

13. Executing Verilog backend.

13.1. Executing BMUXMAP pass.

13.2. Executing DEMUXMAP pass.
Dumping module `\reg_err_detect'.

14. Executing JSON backend.

15. Printing statistics.

=== reg_err_detect ===

   Number of wires:                232
   Number of wire bits:            400
   Number of public wires:          24
   Number of public wire bits:     170
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                307
     $_AND_                        135
     $_DFFE_PN0N_                   16
     $_DFFE_PN0P_                   16
     $_DFFE_PP_                     40
     $_DFF_PN0_                      7
     $_NOT_                         16
     $_OR_                          48
     $_SDFFCE_PN0P_                  2
     $_SDFFCE_PN1P_                  1
     $_XOR_                         26

Warnings: 3 unique messages, 3 total
End of script. Logfile hash: 4e751a5fd6, CPU: user 0.34s system 0.01s, MEM: 16.69 MB peak
Yosys 0.33 (git sha1 2584903a060)
Time spent: 21% 17x opt_expr (0 sec), 18% 1x abc (0 sec), ...
