/* Generated by Yosys 0.33 (git sha1 2584903a060) */

(* dynports =  1  *)
(* top =  1  *)
(* src = "rtl/bcw_mgr.sv:20.1-127.10" *)
module bcw_mgr(clk, rst_n, update_req, bcw_reg_in, update_req_burst, burst_len, update_ack, bcw_reg_out, bcw_valid, error, busy, processed_count);
  wire _0_;
  wire _1_;
  wire _2_;
  wire _3_;
  (* src = "rtl/bcw_mgr.sv:29.39-29.49" *)
  input [31:0] bcw_reg_in;
  wire [31:0] bcw_reg_in;
  (* src = "rtl/bcw_mgr.sv:35.39-35.50" *)
  output [31:0] bcw_reg_out;
  wire [31:0] bcw_reg_out;
  (* src = "rtl/bcw_mgr.sv:36.39-36.48" *)
  output bcw_valid;
  wire bcw_valid;
  (* src = "rtl/bcw_mgr.sv:46.33-46.43" *)
  wire [2:0] burst_cntr;
  (* src = "rtl/bcw_mgr.sv:31.39-31.48" *)
  input [2:0] burst_len;
  wire [2:0] burst_len;
  (* src = "rtl/bcw_mgr.sv:47.11-47.21" *)
  reg burst_mode;
  (* src = "rtl/bcw_mgr.sv:40.39-40.43" *)
  output busy;
  wire busy;
  (* src = "rtl/bcw_mgr.sv:24.39-24.42" *)
  input clk;
  wire clk;
  (* src = "rtl/bcw_mgr.sv:39.39-39.44" *)
  output error;
  wire error;
  (* src = "rtl/bcw_mgr.sv:41.39-41.54" *)
  output [2:0] processed_count;
  wire [2:0] processed_count;
  (* src = "rtl/bcw_mgr.sv:45.31-45.38" *)
  wire [31:0] reg_bcw;
  (* src = "rtl/bcw_mgr.sv:25.39-25.44" *)
  input rst_n;
  wire rst_n;
  (* enum_value_00 = "\\IDLE" *)
  (* enum_value_01 = "\\UPDATE" *)
  (* enum_value_10 = "\\BURST" *)
  (* enum_value_11 = "\\ERROR" *)
  (* src = "rtl/bcw_mgr.sv:52.13-52.18" *)
  (* wiretype = "\\state_t" *)
  wire [1:0] state;
  (* enum_value_00 = "\\IDLE" *)
  (* enum_value_01 = "\\UPDATE" *)
  (* enum_value_10 = "\\BURST" *)
  (* enum_value_11 = "\\ERROR" *)
  (* src = "rtl/bcw_mgr.sv:52.20-52.30" *)
  (* wiretype = "\\state_t" *)
  wire [1:0] state_next;
  (* src = "rtl/bcw_mgr.sv:32.39-32.49" *)
  output update_ack;
  wire update_ack;
  (* src = "rtl/bcw_mgr.sv:28.39-28.49" *)
  input update_req;
  wire update_req;
  (* src = "rtl/bcw_mgr.sv:30.39-30.55" *)
  input update_req_burst;
  wire update_req_burst;
  assign _0_ = ~burst_len[2];
  assign _1_ = burst_len[0] | burst_len[1];
  assign _2_ = ~_1_;
  assign _3_ = _0_ & burst_mode;
  assign update_ack = _2_ & _3_;
  (* \always_ff  = 32'd1 *)
  (* src = "rtl/bcw_mgr.sv:63.5-84.8" *)
  always @(posedge clk, negedge rst_n)
    if (!rst_n) burst_mode <= 1'h0;
    else burst_mode <= update_req_burst;
  assign bcw_reg_out = 32'd0;
  assign bcw_valid = 1'h0;
  assign burst_cntr = 3'h0;
  assign busy = 1'h0;
  assign error = 1'h1;
  assign processed_count = 3'h0;
  assign reg_bcw = 32'd0;
  assign state = 2'h3;
  assign state_next = 2'h0;
endmodule
